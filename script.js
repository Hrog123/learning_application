
questions = [
    { question: 'Wo beginnt ein Beweis über vollständige Induktion?', label: 'Lineare Algebra', answers: [{ answer: 'Bei n = 0', key: 0 }, { answer: 'Bei n = 1', key: 0 }, { answer: 'Bei N=0', key: 0 }, { answer: 'Bei n = x, eben dort, ab wo wir es beweisen wollen.', key: 1 }] },

    { question: 'Welchen Winkel hat die Zahl 1+1i in den Komplexen Zahlen?', label: 'Lineare Algebra', answers: [{ answer: '0', key: 0 }, { answer: '135', key: 0 }, { answer: '45', key: 1 }, { answer: '90', key: 0 }] },

    { question: 'Welche Eigenschaft muss eine abelsche Gruppe im Vergleich zu einer Gruppe haben?', label: 'Lineare Algebra', answers: [{ answer: 'Assozitivität', key: 0 }, { answer: 'Kommutativität', key: 1 }, { answer: 'Distributivität', key: 0 }, { answer: 'Inversität', key: 0 }] },

    { question: 'Der Betrag einer imaginären Zahl a +bi berechnet sich durch die Formel…', label: 'Lineare Algebra', answers: [{ answer: 'a²+b²', key: 0 }, { answer: 'a²-b²', key: 0 }, { answer: 'sqrt(a²+b²)', key: 1 }, { answer: 'sqrt(a²-b²)', key: 0 }] },

    { question: 'Der Begriff ggT ist eine Abkürzung für…?', label: 'Lineare Algebra', answers: [{ answer: 'Größter gemeinsamer Term', key: 0 }, { answer: 'Größter gemeinsamer Teiler', key: 1 }, { answer: 'Größter ganze Teiler', key: 0 }, { answer: 'Gemeinsamer ganzer Teiler', key: 0 }] },

    { question: 'Das Zeichen ^ steht in der Logik für…?', label: 'Lineare Algebra', answers: [{ answer: 'und', key: 1 }, { answer: 'oder', key: 0 }, { answer: 'entweder oder', key: 0 }, { answer: 'nicht', key: 0 }] },

    { question: 'Beim indirekten Beweis fängt man womit an?', label: 'Lineare Algebra', answers: [{ answer: 'Mit einer wahren Aussage', key: 0 }, { answer: 'Mit dem Gegenteil von dem, was zu beweisen ist', key: 1 }, { answer: 'Mit einer unwahren Aussage', key: 0 }, { answer: 'Mit dem euklidischen Algorithmus', key: 0 }] },

    { question: 'Der euklidische Algorithmus beschäftigt sich mit…?', label: 'Lineare Algebra', answers: [{ answer: 'dem ggT', key: 1 }, { answer: 'dem kgV', key: 0 }, { answer: 'den imaginären Zahlen', key: 0 }, { answer: 'Modulo-Rechnung', key: 0 }] },

    { question: 'Welche Eigenschaft gehört nicht zu Relationen?', label: 'Lineare Algebra', answers: [{ answer: 'Symmetrie', key: 0 }, { answer: 'Antisymmetrie', key: 0 }, { answer: 'Antitransivität', key: 1 }, { answer: 'Reflexivität', key: 0 }] },

    { question: 'Welche dieser Mengen ist am größten?', label: 'Lineare Algebra', answers: [{ answer: 'Reelle Zahlen zwischen 0 und 1', key: 1 }, { answer: 'Natürliche Zahlen', key: 0 }, { answer: 'Ganze Zahlen', key: 0 }, { answer: 'Rationale Zahlen', key: 0 }] },

    { question: 'Was ist die untere Schranke eines Algorithmus?', label: 'Theoretische Informatik', answers: [{ answer: 'Die Tilde-Notation', key: 0 }, { answer: 'Omega-Notation', key: 1 }, { answer: 'Theta-Notaion', key: 0 }, { answer: 'O-Notation', key: 0 }] },

    { question: 'Welche obere Schranke stimmt für den Term 3n²+7n?', label: 'Theoretische Informatik', answers: [{ answer: 'O(1)', key: 0 }, { answer: 'O(0)', key: 0 }, { answer: 'O(n)', key: 0 }, { answer: 'O(n²)', key: 1 }] },

    { question: 'Ein Algortihmus..,?', label: 'Theoretische Informatik', answers: [{ answer: 'hat endlich viele Schritte', key: 1 }, { answer: 'hat unnendlich viele Schritte', key: 0 }, { answer: 'darf uendlich viel Speicher nutzen', key: 0 }, { answer: 'muss nicht eindeutig sein', key: 0 }] },

    { question: 'Lineare Suche hat eine Laufzeit von…?', label: 'Theoretische Informatik', answers: [{ answer: 'O(1)', key: 0 }, { answer: 'O(log(n))', key: 0 }, { answer: 'O(n)', key: 1 }, { answer: 'O(n²)', key: 0 }] },

    { question: 'Was bedeutet O(1)?', label: 'Theoretische Informatik', answers: [{ answer: 'Konstante Zeit', key: 1 }, { answer: 'Unendliche Zeit', key: 0 }, { answer: 'Quadratische Laufzeit', key: 0 }, { answer: 'Negative Laufzeit', key: 0 }] },

    { question: 'Wie verhält sich die Laufzeit bei doppeltem n bei O(n³)?', label: 'Theoretische Informatik', answers: [{ answer: '8-fache Laufzeit', key: 1 }, { answer: '6-fache Laufzeit ', key: 0 }, { answer: '2-fache Laufzeit', key: 0 }, { answer: '0,5-fache Laufzeit', key: 0 }] },

    { question: 'Was ist der Unterschied von O(1) und O(2)?', label: 'Theoretische Informatik', answers: [{ answer: 'Nichts', key: 1 }, { answer: 'Alles', key: 0 }, { answer: '2-fache Laufzeit', key: 0 }, { answer: '0,5-fache Laufzeit', key: 0 }] },

    { question: 'Binäre Suche hat eine Laufzeit von…?', label: 'Theoretische Informatik', answers: [{ answer: 'O(1)', key: 0 }, { answer: 'O(log(n))', key: 1 }, { answer: 'O(n)', key: 0 }, { answer: 'O(n²)', key: 0 }] },

    { question: 'Bei der binären Suche wird das Array wie in jedem Schritt verändert?', label: 'Theoretische Informatik', answers: [{ answer: 'Es wird halbiert', key: 1 }, { answer: 'Es wird verdoppelt', key: 0 }, { answer: 'Es wird quadriert', key: 0 }, { answer: 'Es wird die Wurzel aus dem Array berechnet', key: 0 }] },

    { question: 'Der Index -1 steht in Python für welches Element einer Liste?', label: 'Theoretische Informatik', answers: [{ answer: 'Das Erste', key: 0 }, { answer: 'Das Mittlerste', key: 0 }, { answer: 'Das Letzte', key: 1 }, { answer: 'Das Vorletzte', key: 0 }] },

    { question: 'Warum können manche IP-Adressen doppelt vergeben werden?', label: 'Web Engineering', answers: [{ answer: 'Wegen privaten Netzwerken', key: 1 }, { answer: 'Wegen öffentlichen Netzwerken', key: 0 }, { answer: 'Wegen der NASA', key: 0 }, { answer: 'Wegen den DNS-Serven', key: 0 }] },

    { question: 'Was macht man normalerweise mit dem “ping” Befehl?', label: 'Web Engineering', answers: [{ answer: 'Pakete senden', key: 0 }, { answer: 'Netzwerkstatus des Servers prüfen', key: 1 }, { answer: 'Herausfinden, welchen Weg die Anfrage geht', key: 0 }, { answer: 'Die IP-Adresse des Servers herausfinden', key: 0 }] },

    { question: 'DNS steht für...?', label: 'Web Engineering', answers: [{ answer: 'Domain Name System', key: 1 }, { answer: 'Domain Name Server', key: 1 }, { answer: 'Dancing Ninja Squirrles', key: 0 }, { answer: 'Dramatic Nonsense Script', key: 0 }] },

    { question: 'HTML steht für…?', label: 'Web Engineering', answers: [{ answer: 'Hyper Transfer Markup Language', key: 0 }, { answer: 'Hyper Text Makeup Language', key: 0 }, { answer: 'Hyper Text Markup Language', key: 1 }, { answer: 'High Technical Markup Language', key: 0 }] },

    { question: 'Auf welcher Schicht des OSI-Referenzmodells ist Wireless LAN (WLAN/Wi-Fi) angesiedelt?', label: 'Web Engineering', answers: [{ answer: 'Data-Link', key: 1 }, { answer: 'Application', key: 0 }, { answer: 'Session', key: 0 }, { answer: 'Presentaion', key: 0 }] },

    { question: 'Alle Priester saufen … nach der Predigt.', label: 'Web Engineering', answers: [{ answer: 'Tequila', key: 1 }, { answer: 'Wodka', key: 0 }, { answer: 'Jägermeister', key: 0 }, { answer: 'Gin', key: 0 }] },

    { question: 'Wie viele Aufgaben hat eine Schicht im OSI-Modell?', label: 'Web Engineering', answers: [{ answer: 'Keine', key: 0 }, { answer: 'Eine', key: 1 }, { answer: 'Zwei', key: 0 }, { answer: 'Drei', key: 0 }] },

    { question: 'Wie viele Schichten hat das OSI-Modell?', label: 'Web Engineering', answers: [{ answer: '3', key: 0 }, { answer: '4', key: 0 }, { answer: '7', key: 1 }, { answer: '8', key: 0 }] },

    { question: 'Wie viele Schichten hat das TCP/IP-Modell?', label: 'Web Engineering', answers: [{ answer: '3', key: 0 }, { answer: '4', key: 1 }, { answer: '7', key: 0 }, { answer: '8', key: 0 }] },

    { question: 'Wie viele Bits ist eine IPv6-Adresse lang.', label: 'Web Engineering', answers: [{ answer: '32', key: 0 }, { answer: '64', key: 0 }, { answer: '128', key: 1 }, { answer: '256', key: 0 }] },

]



const numOfQuestions = 10;      // Die Anzahl der Fragen, nachder das Quiz vorbei ist.

let pointCounter = 0;           // Zwei einfache Counter, welche zählen, wie viele Fragen bereits bearbeitet wurden,
let questionCounter = 0;        // und wie viele davon richtig beantwortet wurden.
let visibleQuestion = 0;        // Index der gerade angezeigten Frage
let startingTime = 0;           // Zeitstempel bei Beginn der ersten Frage
let endingTime = 0;             // Zeitstempel bei Abschluss der letzten Frage
let timeUsed = 0;               // Gesamtzeit die zur Beantwortung der Fragen genutzt wird.
let usedQuestions = [-1];       // Gestelle Fragen
let givenAnswers = [-1];        // Gegebene Antworten

// console.log(questions);



const randomIndex = () => {     // Bestimmt einen random Array-Index, damit eine zufällige Frage als
    // nächstes ausgewählt wird
    let i = Math.floor((Math.random() * questions.length)) % questions.length;
    return i;
}

const randomQuestion = () => {  // Lädt beim aufrufen eine zufällige neue Frage.
    let i = randomIndex();
    i = onlyOnce(i);
    visibleQuestion = i;
    mixArray(questions[i].answers);
    document.getElementById('displayQuestion').innerHTML = questions[i].question;
    document.getElementById('displayAnswerA').innerHTML = questions[i].answers[0].answer;
    document.getElementById('displayAnswerB').innerHTML = questions[i].answers[1].answer;
    document.getElementById('displayAnswerC').innerHTML = questions[i].answers[2].answer;
    document.getElementById('displayAnswerD').innerHTML = questions[i].answers[3].answer;

    document.getElementById('Anzahl').innerHTML = (questionCounter+1);
}

const firstChoice = () => {     // Wird eine Antwort angeklickt, so wird anhand des answers.key value
    // der Punktestand angepasst.
    questionCounter++;
    pointCounter += questions[visibleQuestion].answers[0].key;
    (questionCounter >= numOfQuestions) && ending();
};

const secondChoice = () => {
    questionCounter++;
    pointCounter += questions[visibleQuestion].answers[1].key;
    (questionCounter >= numOfQuestions) && ending();
};

const thirdChoice = () => {
    questionCounter++;
    pointCounter += questions[visibleQuestion].answers[2].key;
    (questionCounter >= numOfQuestions) && ending();
};

const fourthChoice = () => {
    questionCounter++;
    pointCounter += questions[visibleQuestion].answers[3].key;
    (questionCounter >= numOfQuestions) && ending();
};

// Diese Funktion nimmt ein beliebig großes Array und vermischt die Elemente zufällig.
const mixArray = (arr) => {
    const mixer = Math.floor((Math.random() * 1000)) % arr.length;
    for (let i = 0; i < arr.length / 2; i++) {
        [arr[i], arr[(Math.floor(i + mixer / 2) + 1) % arr.length]] = [arr[(Math.floor(i + mixer / 2) + 1) % arr.length], arr[i]];
    }
}

// Grundinitialisierung der Antwortarrays, bevor die erste Frage gestellt wird, um die Antwortmöglichkeiten zu mischen.
const initializingRandomPlacedQuestions = (arr) => {
    for (let i = 0; i < arr.length; i++) {
        mixArray(arr[i].answers);
    }
}

const starting = () => {    // Diese Funktion startet das Quiz, blendet den Startbildschirm aus und lädt die erste Frage.
    usedQuestions = [-1];
    givenAnswers = [-1];
    initializingRandomPlacedQuestions(questions);
    randomQuestion();
    timerStart();
    document.getElementById('welcome').style.display = "none";
    document.getElementById('playing').style.display = "block";
    document.getElementById('aftermatch').style.display = "none";
}

const ending = () => {      // Diese Funktion beendet das Quiz, sie wird aufgerufen, sobald der QuestionCounter >= numOfQuestions ist.
    timerEnd();
    document.getElementById('timeNeeded').innerHTML = timeUsed;
    document.getElementById('numPoints').innerHTML = pointCounter;
    document.getElementById('numQuestions').innerHTML = questionCounter;
    pointCounter = questionCounter = 0;
    document.getElementById('playing').style.display = "none";
    document.getElementById('aftermatch').style.display = "flex";
}
const back = () => {
    document.getElementById('playing').style.display = "none";
    document.getElementById('aftermatch').style.display = "none";
    document.getElementById('welcome').style.display = "block";
}


const leaderboard = () => {
    document.getElementById('playing').style.display = "none";
    document.getElementById('aftermatch').style.display = "none";
    document.getElementById('welcome').style.display = "none";
    document.getElementById('leaderboard').style.display = "block";
}
const returnLeaderboard = () => {
    document.getElementById('playing').style.display = "none";
    document.getElementById('aftermatch').style.display = "none";
    document.getElementById('welcome').style.display = "block";
    document.getElementById('leaderboard').style.display = "none";
}

const timerStart = () => {                          // Eine Funktion, die die Startzeit festhält
    startingTime = Date.now();
}

const timerEnd = () => {                            // Eine Funktion, die die Endzeit festhält und die Gesamtzeit in xx,x Sekunden berechnet.
    endingTime = Date.now();
    timeUsed = Math.floor((endingTime-startingTime)/100)/10
}


const onlyOnce = (index) => {                       // Eine Funktion, die die bereits genutzen Fragen herausfiltert.
    for (let i = 0; i < usedQuestions.length; i++) {
        if(usedQuestions[i] === index) {
            //console.log("Wir hatten schon " + index);
            index = randomIndex();
            //console.log("Wir versuchen nun " + index);
            i = 0;
        }
    }
    usedQuestions.push(index);
    //console.log(usedQuestions);
    return index;
}

const testArr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];      // Ein Array zum Testen der Array-Vertauschung.

